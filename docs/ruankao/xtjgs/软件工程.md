# 软件开发方法

## 软件开发方法

### 结构化法
- 用户至上
- 严格区分工作阶段，每阶段有任务与成果
- 强调系统开发过程的整体性与全局性
- 系统开发过程工程化，文档资料标准化
- 自顶向下，逐级分解（求精）

面向过程，不能灵活变动

### 原型法
- 适用于需求不明确的开发
- 包括抛弃型原型和进化型原型

用于需求分析阶段

### 面向对象方法
- 更好的复用性
- 关键在于建立一个全面、合理、统一的模型
- 分析、设计、实现三个阶段，界限不明确

### 面向服务方法
- SO方法有三个主要抽象级别：操作、服务、业务流程
- SOAD分为三个层次：基础设计蹭（底层服务构件）、应用结构层（服务之间的接口和服务级协定）和业务组织层（业务员流程建模和服务流程编排）
- 服务建模：分为服务发现、服务规约和服务实现三个阶段

## 软件开发模型

- `瀑布模型（SDLC）`  
  - 适合与需求明确的项目  
  - ![瀑布模型](../img/瀑布模型.png)
- 演化模型
- 增量模型
  - ![增量模型](../img/增量模型.png)
- `螺旋模型`
  - 适合与大型系统，引入了风险分析
  - ![螺旋模型](../img/螺旋模型.png)
- `原型模型`
  - 抛弃型原型（快速原型模型）
  - 进化型模型
- 喷泉模型
  - 面向对象模型
- V模型
  - 强调测试贯穿与始终的模型（测试尽早做、提前做）
  - ![V模型](../img/V模型.png)
- 迭代模型/迭代开发方法
- 快速应用开发（RAD）
  - ![快速应用开发](../img/快速应用开发.png)
- 构建组装模型/基于构件的开发方法（CBSD）
  - 构件库是快的核心
  - 优点：快、节省成本、可靠性高
  - ![构件组装模型](../img/构件组装模型.png)
- `统一过程/统一过程开发（UP/RUP）`
  - ![统一过程](../img/统一过程.png)
- `敏捷开发方法`
  - 小步快跑模式，适合小型项目开发
  - 4大价值观；5大原则；12大最佳实践
  - 开发方法：
    - XP(Extreme Programming, 极限编程)在一些`对费用控制严格的公司中使用`，已经被证实是`非常有效`的
    - 水晶方法：`用最少纪律约束仍能成功的方法`
    - 开放式源码：指`程序开发人员在地域上分布很广`
    - SCRUM：`明确定义了可重复的方法过程`
      - 2-4周一个冲刺（发布一个可用版本）
      - ![Scrum开发模型](../img/Scrum开发模型.png)
    - FDD(Feature Driven Development, 功用驱动开发方法)：开发人员分为两类：`首席程序员和类程序员`
    - ASD(Adaptive Software Development, ASD方法)：其核心是三个非线性的、重叠的开发阶段：`猜测、合作与学习`
  - ![敏捷方法](../img/敏捷方法.png)
- 模型驱动的开发方法
- `基于架构的开发方法`

![其他经典模型](../img/其他经典模型.png)

## 逆向工程

![逆向工程](../img/逆向工程.png)

- 实现级：包括程序的`抽象语法树`、`符号表`、`过程`的设计表示
- 结构级：包括反映`程序分量之间相互依赖关系`的信息，例如调用图、结构图、程序和数据结构
- 功能级：包括反映`程序段功能及程序段`之间关系的信息，例如数据和控制流模型
- 领域级：包括反映程序分量或程序诸如实体与`应用领域概念之间的对应关系`的信息，例如实体关系模型

## 净室软件工程

- 净室即无尘室、洁净室，也就是一个受控污染级别的环境
- 使用盒结构规约（或形式化方法）进行分析和设计建模，并且强调将正确性验证，而不是测试，作为发现和消除错误的主要机制
- 使用统计的测试来获取认证被交付的软件的可靠性所必须的出错率信息

# 需求工程

- 软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望
- 软件需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明

![需求工程-概述](../img/需求工程-概述.png)
> - 需求开发偏向技术维度
>   - 需求定义产出 SRS（需求规格说明书）
>   - 需求验证产出 需求的基线（文档）

## 需求获取

从技术角度分类：
- 业务需求 → 层级较高的需求
- 用户需求
- 系统需求 → 计算机化

对`系统需求`进一步细分：
- 功能需求
- 性能需求：例子：加载速度、响应速度
- 设计约束：例子：客户提出要用xx数据库、xx系统

从`项目管理`角度分类：
- 基本需求：用户明确提出来的
- 期望需求：隐含需求，对客户来说不需要提出就应该有的
- 兴奋需求：（镀金）客户没有提出但系统提供

需求获取的方法
- 收集资料
- 联合讨论会
- 用户访谈
- 书面调查
- 现场观摩
- 参加业务实践
- 阅读历史文档
- 抽样调查（节省成本，以小概全）

## 需求分析

### 结构分析（SA）

- 数据字典：数据元素、数据结构、数据流、数据存储、加工逻辑、外部实体
- 功能模型
  - 数据流图（DFD）：数据流、加工、数据存储、外部实体
- 数据模型
  - E-R图：实体、联系
- 行为模型
  - 状态转换图：状态（初态、终态）、事件

### 面向对象分析（OOA）

概念：对象(对象、属性、名称(id))、类（实体类、边界类、控制类）、抽象、封装、继承与泛化、多态、接口（只有方法的定义，没有方法实现）、消息、组件、模式和复用

- 实体类：映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息
- 控制类：用于控制用力工作的类，一般由动宾结构的短语转化来的名词
- 边界类：用于封装在用例内、外流动的信息回数据流。边界类位于系统于外界的交界处，包括所有窗体、报表、打印机和扫描仪等硬件接口，以及其他系统的接口

## UML

- 构造块
  - 事物
    - 结构事物：`最静态的部分`，包括：类、接口、协作、用例、活动类、构件和节点
    - 行为事物：代表时间和空间上的`动作`，包括：消息、动作次序、连接
    - 分组事物：看成一个盒子，如：包、构件
    - 注释事物：UML模型的`解释部分`。描述、说明和标注模型的元素
  - 关系
  - 图
- 规则
  - 范围：给一个名字以特定含义的语境
  - 可见性：怎样使用或看见名字
  - 完整性：事物如何正确、一致地相互联系
  - 执行：运行或模拟动态模型的含义是什么
- 公共机制
  - 规格说明：事物语义的细节描述，它是模型真正的核心
  - 修饰：通过修饰来表达更多的信息
  - 公共分类：类属于对象、接口以实现
  - 扩展机制：允许添加新的规则

### 4+1视图
- 1：这个1跟其他4个都有联系
  - 用例视图（use-case view）: 需求分析模型 —— 最终用户
- 4
  - 逻辑视图（logical view）: 表现为：类与对象（系统的功能） —— 系统分析、设计人员
  - 实现视图（implementation view）: 表现为：物理代码文件和组件 —— 程序员
  - 进程视图（process view）: 表现为：线程、进程、`并发` —— 系统集成人员
  - 部署视图（deployment view）: 表现为：软件到硬件的映射 —— 系统和网络工程师

逻辑视图 → 实现试图/进程试图 → 部署试图

### UML图

- 静态图（结构图）
  - 类图：一组类、接口、协作和它们之间的关系
  - 对象图：一组对象及它们之间的关系
  - 构件图：一个封装的类和它的接口
  - 部署图：`软硬件之间的映射`
  - 制品图：系统的物理结构
  - 包图：由模型本身分解而成的组织单元，以及它们之间的依赖关系
  - 组合机构图

- 动态图（行为图）
  - `用例图：系统与外部参与者的交互`
  - `顺序图：强调按时间顺序`
  - `通信图（协作图）`
  - 状态图：状态转换变迁
  - `活动图：类似程序流程图，并行行为`
  - 定时图：强调实际时间
  - 交互概览图

#### 用例模型（用例图）
`用例图描述一组用例、参与者及它们之间的关系`
1. 用户角度描述系统功能；
2. 参与者是外部触发因素（包括用户、组织、外部系统、时间）；
3. 用例是功能单元

用例建模的流程：
1. 识别参与者（必须）
2. 合并需求获得用例（必须）
3. 细化用例描述（必须） 
   1. 用例名称
   2. 简要说明
   3. 事件流
   4. 非功能性需求
   5. 前置条件
   6. 后置条件
   7. 扩展点
   8. 优先级
4. 调整用例模型（可选）
   1. 包含关系（使用关系）：当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示。提取出来公共的用例称为抽象用例，把原始用例称为基本用例或基础用例。`基础用例 ——<<include>>--> 抽象用例`
   2. 扩展关系：一个用例明显混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，应使用扩展关系。分为一个基本用例和一个或多个扩展用例。`基础用例 <——<<extend>>—— 扩展用例`
   3. 泛化关系：当多个用例共同拥有一种类似的结构和行为的社会，可以将它们的共性抽象成父用例，其他用例作为泛化关系中的子用例。`子用例 ————▷ 父用例`

![用例图关系](../img/用例图关系.png)
> - **包含关系**与**泛化关系**的区别在于是否存在父子关系
> - **包含关系**与**扩展关系**都可以称为依赖关系

#### 分析模型（类图）
  - 定义概念类
  - 识别类之间的关系
  - 为类添加职责
  - 建立交互图

类图（class diagram）：类图描述一组类、接口、协作和它们之间的关系
对象图（object diagram）：对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照

- 类名，方法名，属性名
- 多重度
  - `1`：表示一个集合中的一个对象对应的另一个集合中的一个对象
  - `0..*`：表示一个集合中的一个对象对应另一个集合中的0个或多个对象（可以不对应）
  - `1..*`：表示一个集合中的一个对象对应另一个集合中的1个或多个对象（至少对应一个）
  - `*`：表示一个集合中的一个对象对用另一个集合中的多个对象
- 关系
  - 依赖关系：一个事物发生变化影响另一个事物
  - 关联关系：描述了一组链，链是对象之间的连接
    - 聚合关系：整体与部分的生命周期`不同`
    - 组合关系：整体与部分的生命周期`相同`
  - 泛化关系：特殊（子类）/一般（父类）关系
  - 实现关系：接口与类之间的关系

![关系图](../img/分析模型-关系图-1.png)
![关系图](../img/分析模型-关系图-2.png)

#### 顺序图（时序图）
顺序图（sequence diagram， 序列图）是一种交互图，他强调对象之间消息发送的顺序，同属显示对象之间的交互

![时序图](../img/时序图.png)

#### 活动图
活动图（activity diagram）将进程或其他计算结构展示为计算内部一步步的控制流和数据流。活动图专注于系统的动态视图。它对系统的功能建模和业务流程建模特别重要，并强调对象间的控制流程。

![活动图](../img/活动图.png)

> 泳道式活动图
> 
> ![泳道式活动图](../img/泳道式活动图.png)

#### 状态图
状态图（state diagram）描述一个状态机，它由状态、转移、事件和活动组成。状态图给出了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调事件导致的对象行为，这非常有助于反应式系统建模

![状态图](../img/状态图.png)

#### 通信图（协作图）
通信图（communication diagram）也是一种交互图，它强调收发消息的对象或参与者的组织结构。顺序图和通信图表达了类似的基本概念，但它们所强调的概念不同，顺序图强调的是时序，通信图强调的是对象之间的组织结构（关系）

![通信图](../img/通信图.png)

### UML关系

# 软件系统建模

# 软件设计

# 测试与评审

# 系统运行与维护