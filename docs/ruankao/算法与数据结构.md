# 算法与数据结构

---
哈夫曼编码是一种一致性编码，又称熵编码法，用于数据的无算耗压缩。

---
逆波兰式，也叫后缀表达式，是将运算符写在操作数之后的表示方法。对逆波兰式求值的方法是从左至右扫描表达式，遇到操作数则压栈，遇到运算符号则从栈中弹出操作数进行运算，然后将结果压入栈中，重复该过程直至表达式结束，最后栈顶的元素即为结果。

---
二维数组：`arr[M,N]`指一个`M行N列`的二维数组

将二维数组元素存储到存储器中有两种主要技术 ：

1. 按行存储：二维数组的所有行连续地存储在存储器中。
2. 按列存储：二维数组的所有列都连续地存储在存储器中。

> 如下的二维数组中：
>
> ||||
> |----|----|----|
> |(0,0)|(0,1)|(0,2)|
> |(1,0)|(1,1)|(1,2)|
> |(2,0)|(2,1)|(2,2)|
>
> 1. 按照行主顺序的存储：(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)。数组的第一行完全存储到存储器中，然后数组的第二行完全存储到存储器中，直到最后一行也完全存储到存储器。
> 2. 按照列主顺序的存储：(0,0),(1,0),(2,0),(0,1),(1,1),(2,1),(0,2),(1,2),(2,2)。数组的第一列完全存储到存储器中，然后数组的第二列完全存储到存储器中，直到数组的最后一列。
>
> 计算二维数组随机元素的地址:
>
> 问题：若二维数组 arr[1..M, 1..N] 的首地址为 base，数组元素按列存储且每个元素占用 K 个存储单元，则元素 arr[i,j] 在该数组空间的地址为（`C`）。  
> A.`base+((i-l)*M+j-1)*K`    B.`base+((i-l)*N+j-l)*K`    C.`base+((j-l)*M+i-l)*K`    D.`base+((j-l)*N+i-l)*K`
>
> - 分析：M行N列，一列有M个元素，一行有N个元素，arr[i,j]是第i行第j个元素。
> - 按行的地址：前面有`i-1`行的是排满的，也就是`(i-1)N`个元素，剩下`j-1`个，得到`(i-1)N+(j-1)+base`
> - 按列的地址：前面有`j-1`列的是排满的，也就是`(j-1)M`个元素，剩下`i-1`个，得到`(j-1)M+(i-1)+base`

---
树的遍历：先序（根左右）、中序（左根右）、后序（左右根）

---
数据挖掘就是应用一些列技术从大型数据库或数据仓库中提取人们感兴趣的信息和知识，这些知识或信息是隐含，事先未知而潜在有用的，提取的知识表示为概念、规则、规律、模式等形式。也就是说数据挖掘是一类深层次的数据分析。常见和应用最广泛的数据挖掘方法如下：

1. 决策树：决策树方法是利用信息论中的互信息（信息增益）寻找数据库中具有最大信息量的属性字段，建立决策树的一个结点，再根据该属性字段的不同区直建设书的分支；在每个分支子集中重复建立树的下层结点和分支的过程。国际上最早的、最有影响的决策树方法是Quiulan研究的ID3方法。
2. 神经网络：神经网络方法是模拟人脑的神经元结构，完成类似统计学中的判断、回归、聚类等功能，是一种非线性的模型，主要有三种神经网络模型：前馈式网络、反馈式网络和自组织网络。
3. 遗传算法：遗传算法是模拟生物进化过程的算法，他由三个基本过程组成：繁殖（选择）、交叉（重组）、变异（突变）。采用遗传算法的可以产生优良的后代。经过若干代的遗传，将得到满足要求的后代即问题得解。
4. 关联规则挖掘算法：关联规则是描述数据之间存在关系的规则，形式为"A1A2A3...An => B1B2B3...Bn"。一般分为两个步骤，求出最大数据项集、用大数据项集缠身关联规则。
5. 除上述常用方法外，还有粗集方法，模糊集合方法，Bayesian Belief Netords，最邻近算法（K-nearest Neighbors Method，KNN）等。

---
二分查找
> 对n个元素的有序表A[1...n]进行二分查找（除2取商时向下取整），查找元素A[i]时，最多与A中的（）个元素进行比较。  
> 解答：第一次二分n/2，第二次二分n/2/2...，第m次二分n/2^m，最坏情况下排除完只剩下一个元素，得到`n/2^m=1`，可以得到`log2(n)=m`，所以二分查找的时间复杂度为`log2(n)`，此时再与最后一个元素进行比较得到`log2(n)+1`

对于数组A[1..n]，查找关键字key使用二分查找法的步骤：1.先计算中间位置下标`mid`；2.若要查找的关键字`key<A[mid]`，说明要找的对象在`A[1]~A[mid-1]`之间，同理，若要查找的关键字`key>A[mid]`，说明要找的对象在`A[mid+1]~A[n]`之间；3.重复上述步骤直至成功找到结果或失败为止。

根据二分查找过程中的关键字序列构造二分查找树判定树：如果根为空，则当前元素为根；比根小的放左边，比根大的放右边；如果左子树不为空，重复上述步骤。

---
对于循环队列，求队头元素的指针的计算公式为：`(rear-len+1+M)%M`。求队列中元素个数（长度）公式为：`(rear-front+M)%M`，其中 front 指队头指针。

---
栈和队列是两种常用的数据结构。栈的特点是后进先出，队列的特点是先进先出。因此入队序列和出队序列一定相同，而入栈序列和出栈序列不一定相同。

栈和队列都是操作首先的线性表：栈仅在表尾插入和删除元素，队列仅在表头删除元素，在队尾插入元素。

---
线性表进行顺序存储时，逻辑上相邻的元素，其物理位置也相邻。在已知第一个元素存储位置和元素序号的情况下，可以计算出任意元素的存储位置，即按照序号访问元素是随机的，该运算的时间复杂度为O(1)；而插入元素时需要移动一些元素，因此该运算的时间复杂度为O(n)，其中n是线性表的长度。

线性表进行链式存储时，逻辑上相邻的元素物理位置上不要求相邻，以此需要额外的存储空间表示元素之间的顺序关系。在链表上查找和插入元素的时间复杂度都为O(n)。

---
对有向无环图进行拓扑排序的方法如下：

1. 在AOV网中选择一个入读为零（没有前驱）的定点且输出它
2. 从网中删除该顶点v以及与该顶点有关的所有边
3. 重复上述两步，直至网中不存在入读为零的顶点为止。

---
二叉树：

- 完全二叉树：除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。
- 平衡二叉树（AVL）：是空树，或者左子树和右子树的深度差值不超过1且它的左子树和右子树都是平衡二叉树。
- 最优二叉树：哈夫曼树
- 满二叉树：每一层上的节点数均达到最大值。

哈夫曼树：是指权值为 w1，w2，...，wn 的n个叶子节点的二叉树中带权路径长度最小的二叉树。树的带权路径长度为树中所有叶子节点的带权路径长度之和。

---
在有向图中，若以顶点表示活动，用有向边表示活动之间的优先关系，则称这样的有向图为以顶点表示活动的网（Activity On Vertex Network，AOV网）。

若在带权有向图G中以顶点表示事件，以有向边表示活动，边上的权值表示该活动持续的时间，则这种带权有向图称为用边表示活动的网（Activity On Edge Network，AOE网），通常在AOE网中列出了完成预定工程计划所需进行的活动、每项活动的计划完成时间、要发生哪些事件以及这些事件和活动时间的关系，从而可以分析该项工程是否实际可行并估计工程完成的最短时间，分析出哪些活动是影响工程进度的关键。进一步可以进行人力、物力的调度和分配，以达到缩短工期的目的。

根据生成树的定义，有n个顶点的联通图的生成树中恰好有n-1条边。

---
**平均**查找长度：对n个元素的有序列表进行顺序查找，其成功查找的平均查找长度是`(n+1)/2`，当查找的元素是第1个元素时进行1次比较，当查找的是第2个元素时进行2次比较，...，当查找的是第n个元素时进行n次比较，所以平均查找长度为`(1+2+3+...+n)/n`

删除一个包含n个元素的有序线性表中的某一个元素，若采用顺序存储时，删除某个元素平均需要移动`(n-1)/2`个元素；若采用单链表存储，不需要移动元素（因为插入和删除都是对指针的操作）。

---
二叉排序树，将新节点插入儿茶排序树时，需要先查找插入位置。若等于树根，则不再插入，偌大于树根，则递归地在右子树上查找插入位置，否则递归地在左子树查找插入位置，因此新结点总是叶子的方式加入树中。这样，在根结点到达每个叶子的路径上，结点的顺序必须保持，也就是父结点必定先于子结点进入树中。

---
对于无向图中的两个顶点u和V，若存在边(u,v)，则该边为计算U的度和V的度各贡献一个值1，因此所有顶点的读书之和为e的两倍。

---
邻接矩阵的定义，行列数都为结点个数。

无向边的邻接矩阵是一个对称矩阵，每条边会表示两次，因此矩阵中的非零元素数目为2x边数

有向边的邻接矩阵的每个非零元素都表示一条边，所以非零元素数目为边数

---
实现函数或过程的递归调用及返回处理时必须用栈。

---
在m阶B-树的定义中，要求：

1. 树中每个节点之多有M棵子树
2. 若根节点不是叶子节点，则至少两两棵子树
3. 除根之外的所有非终端节点至少有[M/2]棵子树

---
图的遍历是指对图中所有顶点进行访问且只访问一次的过程。

深度优先遍历方法：从顶点V出发，依次从V出发搜索V的任意一个邻接点W；若W未被访问过，则从该点出发继续深度优先遍历。类似于树的前序遍历。

广度优先遍历方法：从顶点V出发，访问与顶点V邻接的全部未访问的顶点W、X、Y...；然后再依次访问W、X、Y...的邻接未访问的顶点。引入队列来保存已访问过的顶点序列。

---

- 分治法：把同一个问题拆分成多个小规模的相同子问题，一般可用递归解决
- 动态规划法：划分子问题（最优子结构），并把子问题结果使用数组保存，利用查询子问题结果构造最终问题的结果
- 贪心法：局部最优，但整体不一定最优。每步有明确的、既定的策略
- 回溯法：系统搜索一个问题所有解或任一解。有试探和回退的过程。

---
HASH表的装填因子表示哈希表的装满程度。装填因子越大，冲突可能性越高。

---
各种排序算法对比
<table>
  <thead align="center">
    <tr>
      <td rowspan=2>类别</td>
      <td rowspan=2>排序方法</td>
      <td colspan=2>时间复杂度</td>
      <td >空间复杂度</td>
      <td rowspan=2>稳定性</td>
    </tr>
    <tr>
      <td>平均情况</td>
      <td>最坏情况</td>
      <td>辅助存储</td>
    </tr>
  </thead>
  <tbody align="center">
    <tr>
      <td rowspan=2>插入排序</td>
      <td>直接插入</td>
      <td>O(n^2)</td>
      <td>O(n^2)</td>
      <td>O(1)</td>
      <td>稳定</td>
    </tr>
    <tr>
      <td>Shell排序</td>
      <td>O(n^1.3)</td>
      <td>O(n^2)</td>
      <td>O(1)</td>
      <td>不稳定</td>
    </tr>
    <tr>
      <td rowspan=2>选择排序</td>
      <td>直接选择</td>
      <td>O(n^2)</td>
      <td>O(n^2)</td>
      <td>O(1)</td>
      <td>不稳定</td>
    </tr>
    <tr>
      <td>堆排序</td>
      <td>O(nlog2(n))</td>
      <td>O(nlog2(n))</td>
      <td>O(1)</td>
      <td>不稳定</td>
    </tr>
    <tr>
      <td rowspan=2>交换排序</td>
      <td>冒泡排序</td>
      <td>O(n^2)</td>
      <td>O(n^2)</td>
      <td>O(1)</td>
      <td>稳定</td>
    </tr>
    <tr>
      <td>快速排序</td>
      <td>O(nlog2(n))</td>
      <td>O(n^2)</td>
      <td>O(log2(n))</td>
      <td>不稳定</td>
    </tr>
    <tr>
      <td colspan=2>归并排序</td>
      <td>O(nlog2(n))</td>
      <td>O(nlog2(n))</td>
      <td>O(n)</td>
      <td>稳定</td>
    </tr>
    <tr>
      <td colspan=2>基数排序</td>
      <td>O(d(r+n))</td>
      <td>O(d(r+n))</td>
      <td>O(r+n)</td>
      <td>稳定</td>
    </tr>
  </tbody>
</table>

插入排序：将待排序的数组分为已排好序的和未排好序的两部分，每次从未排好序的部分取出一个元素，按从后往前的顺序依次与已排好序的部分进行比较并将其插入正确的位置，直至所有元素均已排序。

---
递归推导式的方法：

- 代入法
- 递归树法
- 主方法：设 a≥1 和 b＞1 为常数，设 f(n) 为一函数， T(n) 由递归式`T(n)=aT(n/b)+f(n)`对非负整数定义，其中n/b指「n/b|或|n/b」。那么T(n)可能有如下渐进界：
  1. 若对于某常数ε＞0，有f(n)=O(n^logb(a-ε))，则`T(n)=Θ(n^logb(a))`
  2. 若f(n)=Θ(n^logb(a))，则`T(n)=Θ(n^logb(a)lgn)`
  3. 若对于某常数ε＞0，有`f(n)=Ω(n^logb(a+ε))`，且对常数 c＜1 与多有足够大的 n，有af(n/b)≤cf(n)，则T(n)=Θ(f(n))

---
赫夫曼编码压缩比：先计算出需要二进制编码的位数n，然后构造赫夫曼树，得出每个编码的长度，通过`SUM(原编码长度x编码所占比例)/SUM(赫夫曼编码x编码所占比例)`

> 已知某个文档包含5个字符，a：40%，b：10%，c：20%，d：16%，e：14%，则文档的压缩比为____  
> 解答：  
> 采用二进制编码，5个字符需要3位二进制(`2^3=8>5`)，即每位占 3bit，平均字符长度为 3x40%+3x10%+3x20%+3x16%+3x14%=3；采用赫夫曼编码时各编码长度分别为1，3，3，3，3，平均字符长度为 1x40%+3x10%+3x20%+3x16%+3x14%=2.2。所以压缩比为 `(3-2.2)/3 = 27%`。

如何构造赫夫曼树：  
选取数组中值最小的两个数，左小右大构造一颗二叉树，将其结果替换数组中的这两个数，再从数组中选出两个最小的数构造二叉树，依次类推。赫夫曼编码是基于贪心法策略的。

---
矩阵连乘

输入连乘矩阵的个数，每个矩阵的维数。要求输出数乘次数最少时加括号的方式，及数乘次数。

次数：A是一个p×q的矩阵，B是一个q×r矩阵，AB相乘，得到的矩阵元素个数为p×r，每个元素由q次乘法得到，因此所需乘法次数为p×q×r。在计算矩阵连乘积时，加括号的方式对计算量有影响。

> 例如有三个矩阵，A1、A2、A3连乘，它们的维数分别为 10×100，100×5，5×50。  
> 用第一种加括号方式 (A1A2)A3 计算，所需数乘次数为 10×100×5+10×5×50=7500  
> 用第二种加括号方式 A1(A2A3) 计算，所需数乘次数为 10×100×50+100×5×50=75000

![矩阵连乘](./img/矩阵连乘.png "矩阵连乘")

用上述公式计算 A1(10×100)、A2(100×5)、A3(5×50)。p[]={10,100,5,50}

|i \ j|1|2|3|
|---|---|---|---|
|1|0|5000|7500|
|2||0|25000|
|3|||0|

- m[1,1]=m[2,2]=m[3,4]=0
- m[1,2]=m[1,1]+m[2,2]+p0p1p2=0+0+10x100x5=5000
- m[2,3]=m[2,2]+m[3,3]+p1p2p3=0+0+100x5x50=25000
- m[1,3]=min()=7500
  - k=1,m[1,1]+m[2,3]+p0p1p3=0+25000+10x100x50=75000
  - k=2,m[1,2]+m[3,3]+p0p2p3=5000+0+10x5x50=7500
