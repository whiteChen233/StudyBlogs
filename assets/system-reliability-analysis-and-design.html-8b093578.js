import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,f as t}from"./app-ac942868.js";const l="/assets/note/qccstp/系统可靠性分析与设计-可靠性指标.png",d="/assets/note/qccstp/系统可靠性分析与设计-串联系统与并联系统.png",r="/assets/note/qccstp/系统可靠性分析与设计-混合系统.png",n="/assets/note/qccstp/系统可靠性分析与设计-可靠性设计.png",h="/assets/note/qccstp/系统可靠性分析与设计-N版本程序设计.png",s="/assets/note/qccstp/系统可靠性分析与设计-恢复块方法.png",c="/assets/note/qccstp/系统可靠性分析与设计-双机容错.png",o={},u=t('<h2 id="可靠性相关基本概念" tabindex="-1"><a class="header-anchor" href="#可靠性相关基本概念" aria-hidden="true">#</a> 可靠性相关基本概念</h2><h3 id="可靠性与可用性" tabindex="-1"><a class="header-anchor" href="#可靠性与可用性" aria-hidden="true">#</a> 可靠性与可用性</h3><ul><li><em>系统可靠性</em>：是系统再规定的时间内及规定的环境条件下，完成规定功能的能力，也就是系统无故障运行的概率</li><li><em>系统可用性</em>：是指在某个给定时间点上系统能够按照需求执行的概率</li></ul><blockquote><ul><li>论文一般偏向可靠性，案例一般偏向可用性</li><li>提高可靠性需要强调减少系统中断（故障）的次数，提高可用性需要强调减少从灾难中恢复的时间</li></ul></blockquote><h3 id="软件可靠性与硬件可靠性的差异" tabindex="-1"><a class="header-anchor" href="#软件可靠性与硬件可靠性的差异" aria-hidden="true">#</a> 软件可靠性与硬件可靠性的差异</h3><p><code>软件可靠性 ≠ 硬件可靠性</code></p><ul><li>复杂性：软件复杂性比硬件高，大部分失效来自于软件失效</li><li>物理退化：硬件失效主要是物理退化所致，软件不存在物理退化</li><li>唯一性：软件是唯一的，每个 Copy 版本都一样，而两个硬件不可能完全一样</li><li>版本更新周期：硬件较慢，软件较快</li></ul><h2 id="系统可靠性分析" tabindex="-1"><a class="header-anchor" href="#系统可靠性分析" aria-hidden="true">#</a> 系统可靠性分析</h2><h3 id="可靠性指标" tabindex="-1"><a class="header-anchor" href="#可靠性指标" aria-hidden="true">#</a> 可靠性指标</h3><ul><li>平均无故障时间（MTTF）：MTTF = 1/λ，λ 为失效率</li><li>平均故障修复时间（MTTR）：MTTR = 1/μ，μ 为修复率</li><li>平均故障间隔时间（MTBF）：MTBF = MTTR + MTTF</li><li>系统可用性：平均无故障时间/平均故障间隔时间 x100%，即 MTTF/(MTTR + MTTF)x100%</li></ul><figure><img src="'+l+'" alt="系统可靠性分析与设计-可靠性指标" tabindex="0" loading="lazy"><figcaption>系统可靠性分析与设计-可靠性指标</figcaption></figure><blockquote><p>在实际应用中，一般 MTTR 很小，所以通常认为 MTBF≈MTTF</p></blockquote><h3 id="串联系统与并联系统" tabindex="-1"><a class="header-anchor" href="#串联系统与并联系统" aria-hidden="true">#</a> 串联系统与并联系统</h3><figure><img src="'+d+'" alt="系统可靠性分析与设计-串联系统与并联系统" tabindex="0" loading="lazy"><figcaption>系统可靠性分析与设计-串联系统与并联系统</figcaption></figure><h3 id="混合系统" tabindex="-1"><a class="header-anchor" href="#混合系统" aria-hidden="true">#</a> 混合系统</h3><figure><img src="'+r+'" alt="系统可靠性分析与设计-混合系统" tabindex="0" loading="lazy"><figcaption>系统可靠性分析与设计-混合系统</figcaption></figure><h2 id="系统可靠性设计" tabindex="-1"><a class="header-anchor" href="#系统可靠性设计" aria-hidden="true">#</a> 系统可靠性设计</h2><figure><img src="'+n+'" alt="系统可靠性分析与设计-可靠性设计" tabindex="0" loading="lazy"><figcaption>系统可靠性分析与设计-可靠性设计</figcaption></figure><h3 id="处理故障的步骤" tabindex="-1"><a class="header-anchor" href="#处理故障的步骤" aria-hidden="true">#</a> 处理故障的步骤</h3><ol><li>故障检测</li><li>故障屏蔽</li><li>故障限制</li><li>复执故障诊断</li><li>系统重配置</li><li>系统恢复 <ul><li><code>前向恢复</code>：使当前的计算继续下去，把系统恢复成连贯的正确状态，弥补当前状态的不连贯情况 <ul><li>前向恢复适用于可预见的易定义的错误</li><li>前向恢复将对一些变量的状态进行修改和处理，且这个恢复过程将由程序设计者设计</li></ul></li><li><code>后向恢复</code>：系统恢复到前一个正确状态，继续执行 <ul><li>后向恢复可屏蔽不可预见的错误</li><li>后向恢复简单地把变量恢复到检查点的取值</li></ul></li></ul></li><li>系统重新启动</li><li>修复系统重组合</li></ol><h3 id="软件容错" tabindex="-1"><a class="header-anchor" href="#软件容错" aria-hidden="true">#</a> 软件容错</h3><h4 id="n-版本程序设计" tabindex="-1"><a class="header-anchor" href="#n-版本程序设计" aria-hidden="true">#</a> N 版本程序设计</h4><figure><img src="'+h+'" alt="系统可靠性分析与设计-N版本程序设计" tabindex="0" loading="lazy"><figcaption>系统可靠性分析与设计-N版本程序设计</figcaption></figure><ul><li>与通常软件开发过程不同的是，N 版本程序设计增加了三个新的阶段：相异成份规范评审、相异性确认、背对背测试</li><li>N 版本程序的同步、N 版本程序之间的通信、表决算法（全等表决、非精确表决、Cosmetie 表决、一致比较问题、数据相异性）</li></ul><h4 id="恢复块方法" tabindex="-1"><a class="header-anchor" href="#恢复块方法" aria-hidden="true">#</a> 恢复块方法</h4><figure><img src="'+s+'" alt="系统可靠性分析与设计-恢复块方法" tabindex="0" loading="lazy"><figcaption>系统可靠性分析与设计-恢复块方法</figcaption></figure><ul><li>设计时应保证实现主块和后备块之间的独立性，避免相关错误的产生，使主块和备份快之间的共性错误降低到最低程度</li><li>必须保证验证测试程序的正确性</li></ul><h4 id="n-版本程序设计与恢复块方法的区别" tabindex="-1"><a class="header-anchor" href="#n-版本程序设计与恢复块方法的区别" aria-hidden="true">#</a> N 版本程序设计与恢复块方法的区别</h4><table><thead><tr><th></th><th>恢复块方法</th><th>N 版本程序设计</th></tr></thead><tbody><tr><td>硬件运行环境</td><td>单机</td><td>多机</td></tr><tr><td>错误检测方法</td><td>验证测试程序</td><td>表决</td></tr><tr><td>恢复策略</td><td>后向恢复</td><td>前向恢复</td></tr><tr><td>实时性</td><td>差</td><td>好</td></tr></tbody></table><h4 id="防卫式程序设计" tabindex="-1"><a class="header-anchor" href="#防卫式程序设计" aria-hidden="true">#</a> 防卫式程序设计</h4><ul><li>对于程序中存在的错误和不一致性，通过在程序中包含错误检查代码和错误回府代码，使得一旦错误发生，程序能撤销错误状态，恢复到一个已知的正确状态中去</li><li>实现策略：错误检测、破坏估计、错误恢复</li></ul><h3 id="双机容错" tabindex="-1"><a class="header-anchor" href="#双机容错" aria-hidden="true">#</a> 双机容错</h3><figure><img src="'+c+'" alt="系统可靠性分析与设计-双机容错" tabindex="0" loading="lazy"><figcaption>系统可靠性分析与设计-双机容错</figcaption></figure><ul><li>双机热备模式：主系统运行、备用系统停机，心跳连接</li><li>双机互备模式：同时提供不同的服务、心不跳则接管</li><li>双机双工模式：同时提供相同的服务，集群的一种</li></ul><h3 id="集群技术" tabindex="-1"><a class="header-anchor" href="#集群技术" aria-hidden="true">#</a> 集群技术</h3><p>集群系统对比高性能主机系统的优点：</p><ul><li>可伸缩性</li><li>高可用性</li><li>可管理性</li><li>高性价比</li><li>高透明性</li></ul>',37),f=[u];function g(p,b){return a(),e("div",null,f)}const x=i(o,[["render",g],["__file","system-reliability-analysis-and-design.html.vue"]]);export{x as default};
