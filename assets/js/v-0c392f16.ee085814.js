"use strict";(self.webpackChunknote=self.webpackChunknote||[]).push([[7789],{6640:(e,l,i)=>{i.r(l),i.d(l,{default:()=>d});var t=i(6252);const a=[(0,t.uE)('<h2 id="可靠性相关基本概念" tabindex="-1"><a class="header-anchor" href="#可靠性相关基本概念" aria-hidden="true">#</a> 可靠性相关基本概念</h2><h3 id="可靠性与可用性" tabindex="-1"><a class="header-anchor" href="#可靠性与可用性" aria-hidden="true">#</a> 可靠性与可用性</h3><ul><li><em>系统可靠性</em>：是系统再规定的时间内及规定的环境条件下，完成规定功能的能力，也就是系统无故障运行的概率</li><li><em>系统可用性</em>：是指在某个给定时间点上系统能够按照需求执行的概率</li></ul><blockquote><ul><li>论文一般偏向可靠性，案例一般偏向可用性</li><li>提高可靠性需要强调减少系统中断（故障）的次数，提高可用性需要强调减少从灾难中恢复的时间</li></ul></blockquote><h3 id="软件可靠性与硬件可靠性的差异" tabindex="-1"><a class="header-anchor" href="#软件可靠性与硬件可靠性的差异" aria-hidden="true">#</a> 软件可靠性与硬件可靠性的差异</h3><p><code>软件可靠性 ≠ 硬件可靠性</code></p><ul><li>复杂性：软件复杂性比硬件高，大部分失效来自于软件失效</li><li>物理退化：硬件失效主要是物理退化所致，软件不存在物理退化</li><li>唯一性：软件是唯一的，每个Copy版本都一样，而两个硬件不可能完全一样</li><li>版本更新周期：硬件较慢，软件较快</li></ul><h2 id="系统可靠性分析" tabindex="-1"><a class="header-anchor" href="#系统可靠性分析" aria-hidden="true">#</a> 系统可靠性分析</h2><h3 id="可靠性指标" tabindex="-1"><a class="header-anchor" href="#可靠性指标" aria-hidden="true">#</a> 可靠性指标</h3><ul><li>平均无故障时间（MTTF）：MTTF = 1/λ，λ为失效率</li><li>平均故障修复时间（MTTR）：MTTR = 1/μ，μ为修复率</li><li>平均故障间隔时间（MTBF）：MTBF = MTTR + MTTF</li><li>系统可用性：平均无故障时间/平均故障间隔时间x100%，即MTTF/(MTTR + MTTF)x100%</li></ul><p><img src="/assets/qccstp/系统可靠性分析与设计-可靠性指标.png" alt="系统可靠性分析与设计-可靠性指标" loading="lazy"></p><blockquote><p>在实际应用中，一般MTTR很小，所以通常认为MTBF≈MTTF</p></blockquote><h3 id="串联系统与并联系统" tabindex="-1"><a class="header-anchor" href="#串联系统与并联系统" aria-hidden="true">#</a> 串联系统与并联系统</h3><p><img src="/assets/qccstp/系统可靠性分析与设计-串联系统与并联系统.png" alt="系统可靠性分析与设计-串联系统与并联系统" loading="lazy"></p><h3 id="混合系统" tabindex="-1"><a class="header-anchor" href="#混合系统" aria-hidden="true">#</a> 混合系统</h3><p><img src="/assets/qccstp/系统可靠性分析与设计-混合系统.png" alt="系统可靠性分析与设计-混合系统" loading="lazy"></p><h2 id="系统可靠性设计" tabindex="-1"><a class="header-anchor" href="#系统可靠性设计" aria-hidden="true">#</a> 系统可靠性设计</h2><p><img src="/assets/qccstp/系统可靠性分析与设计-可靠性设计.png" alt="系统可靠性分析与设计-可靠性设计" loading="lazy"></p><h3 id="处理故障的步骤" tabindex="-1"><a class="header-anchor" href="#处理故障的步骤" aria-hidden="true">#</a> 处理故障的步骤</h3><ol><li>故障检测</li><li>故障屏蔽</li><li>故障限制</li><li>复执故障诊断</li><li>系统重配置</li><li>系统恢复 <ul><li><code>前向恢复</code>：使当前的计算继续下去，把系统恢复成连贯的正确状态，弥补当前状态的不连贯情况 <ul><li>前向恢复适用于可预见的易定义的错误</li><li>前向恢复将对一些变量的状态进行修改和处理，且这个恢复过程将由程序设计者设计</li></ul></li><li><code>后向恢复</code>：系统恢复到前一个正确状态，继续执行 <ul><li>后向恢复可屏蔽不可预见的错误</li><li>后向恢复简单地把变量恢复到检查点的取值</li></ul></li></ul></li><li>系统重新启动</li><li>修复系统重组合</li></ol><h3 id="软件容错" tabindex="-1"><a class="header-anchor" href="#软件容错" aria-hidden="true">#</a> 软件容错</h3><h4 id="n版本程序设计" tabindex="-1"><a class="header-anchor" href="#n版本程序设计" aria-hidden="true">#</a> N版本程序设计</h4><p><img src="/assets/qccstp/系统可靠性分析与设计-N版本程序设计.png" alt="系统可靠性分析与设计-N版本程序设计" loading="lazy"></p><ul><li>与通常软件开发过程不同的是，N版本程序设计增加了三个新的阶段：相异成份规范评审、相异性确认、背对背测试</li><li>N版本程序的同步、N版本程序之间的通信、表决算法（全等表决、非精确表决、Cosmetie表决、一致比较问题、数据相异性）</li></ul><h4 id="恢复块方法" tabindex="-1"><a class="header-anchor" href="#恢复块方法" aria-hidden="true">#</a> 恢复块方法</h4><p><img src="/assets/qccstp/系统可靠性分析与设计-恢复块方法.png" alt="系统可靠性分析与设计-恢复块方法" loading="lazy"></p><ul><li>设计时应保证实现主块和后备块之间的独立性，避免相关错误的产生，使主块和备份快之间的共性错误降低到最低程度</li><li>必须保证验证测试程序的正确性</li></ul><h4 id="n版本程序设计与恢复块方法的区别" tabindex="-1"><a class="header-anchor" href="#n版本程序设计与恢复块方法的区别" aria-hidden="true">#</a> N版本程序设计与恢复块方法的区别</h4><table><thead><tr><th></th><th>恢复块方法</th><th>N版本程序设计</th></tr></thead><tbody><tr><td>硬件运行环境</td><td>单机</td><td>多机</td></tr><tr><td>错误检测方法</td><td>验证测试程序</td><td>表决</td></tr><tr><td>恢复策略</td><td>后向恢复</td><td>前向恢复</td></tr><tr><td>实时性</td><td>差</td><td>好</td></tr></tbody></table><h4 id="防卫式程序设计" tabindex="-1"><a class="header-anchor" href="#防卫式程序设计" aria-hidden="true">#</a> 防卫式程序设计</h4><ul><li>对于程序中存在的错误和不一致性，通过在程序中包含错误检查代码和错误回府代码，使得一旦错误发生，程序能撤销错误状态，恢复到一个已知的正确状态中去</li><li>实现策略：错误检测、破坏估计、错误恢复</li></ul><h3 id="双机容错" tabindex="-1"><a class="header-anchor" href="#双机容错" aria-hidden="true">#</a> 双机容错</h3><p><img src="/assets/qccstp/系统可靠性分析与设计-双机容错.png" alt="系统可靠性分析与设计-双机容错" loading="lazy"></p><ul><li>双机热备模式：主系统运行、备用系统停机，心跳连接</li><li>双机互备模式：同时提供不同的服务、心不跳则接管</li><li>双机双工模式：同时提供相同的服务，集群的一种</li></ul><h3 id="集群技术" tabindex="-1"><a class="header-anchor" href="#集群技术" aria-hidden="true">#</a> 集群技术</h3><p>集群系统对比高性能主机系统的优点：</p><ul><li>可伸缩性</li><li>高可用性</li><li>可管理性</li><li>高性价比</li><li>高透明性</li></ul>',37)],r={},d=(0,i(3744).Z)(r,[["render",function(e,l){return(0,t.wg)(),(0,t.iD)("div",null,a)}]])},3744:(e,l)=>{l.Z=(e,l)=>{const i=e.__vccOpts||e;for(const[e,t]of l)i[e]=t;return i}},7359:(e,l,i)=>{i.r(l),i.d(l,{data:()=>t});const t=JSON.parse('{"key":"v-0c392f16","path":"/zh/QCCSTP/system-architect/system-reliability-analysis-and-design.html","title":"系统可靠性分析与设计","lang":"zh-CN","frontmatter":{"title":"系统可靠性分析与设计","date":"2022-09-20T00:00:00.000Z","summary":"可靠性相关基本概念 可靠性与可用性 系统可靠性：是系统再规定的时间内及规定的环境条件下，完成规定功能的能力，也就是系统无故障运行的概率; 系统可用性：是指在某个给定时间点上系统能够按照需求执行的概率; \\" - 论文一般偏向可靠性，案例一般偏向可用性\\" \\" - 提高可靠性需要强调减少系统中断（故障）的次数，提高可用性需要强调减少从灾难中恢复的时间\\" 软件可靠性","head":[["meta",{"property":"og:url","content":"https://whiteChen233/whitechen233.github.io/zh/QCCSTP/system-architect/system-reliability-analysis-and-design.html"}],["meta",{"property":"og:site_name","content":"温故而知新~"}],["meta",{"property":"og:title","content":"系统可靠性分析与设计"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-09-26T16:26:29.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"article:published_time","content":"2022-09-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-09-26T16:26:29.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://whiteChen233/whitechen233.github.io/en/QCCSTP/system-architect/system-reliability-analysis-and-design.html"}]]},"excerpt":"","headers":[{"level":2,"title":"可靠性相关基本概念","slug":"可靠性相关基本概念","link":"#可靠性相关基本概念","children":[{"level":3,"title":"可靠性与可用性","slug":"可靠性与可用性","link":"#可靠性与可用性","children":[]},{"level":3,"title":"软件可靠性与硬件可靠性的差异","slug":"软件可靠性与硬件可靠性的差异","link":"#软件可靠性与硬件可靠性的差异","children":[]}]},{"level":2,"title":"系统可靠性分析","slug":"系统可靠性分析","link":"#系统可靠性分析","children":[{"level":3,"title":"可靠性指标","slug":"可靠性指标","link":"#可靠性指标","children":[]},{"level":3,"title":"串联系统与并联系统","slug":"串联系统与并联系统","link":"#串联系统与并联系统","children":[]},{"level":3,"title":"混合系统","slug":"混合系统","link":"#混合系统","children":[]}]},{"level":2,"title":"系统可靠性设计","slug":"系统可靠性设计","link":"#系统可靠性设计","children":[{"level":3,"title":"处理故障的步骤","slug":"处理故障的步骤","link":"#处理故障的步骤","children":[]},{"level":3,"title":"软件容错","slug":"软件容错","link":"#软件容错","children":[]},{"level":3,"title":"双机容错","slug":"双机容错","link":"#双机容错","children":[]},{"level":3,"title":"集群技术","slug":"集群技术","link":"#集群技术","children":[]}]}],"git":{"createdTime":1664012965000,"updatedTime":1664209589000,"contributors":[{"name":"white","email":"294476387@qq.com","commits":2}]},"readingTime":{"minutes":4.25,"words":1275},"filePathRelative":"zh/QCCSTP/system-architect/system-reliability-analysis-and-design.md","localizedDate":"2022年9月20日"}')}}]);