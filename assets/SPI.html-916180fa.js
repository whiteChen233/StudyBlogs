import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as d,c,b as r,d as e,g as i,e as s}from"./app-456379cc.js";const t={},n=e("h2",{id:"spi-是什么",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#spi-是什么","aria-hidden":"true"},"#"),i(" SPI 是什么")],-1),p=e("p",null,"面向的对象的设计里, 一般推荐模块之间基于接口编程, 模块之间不对实现类进行硬编码, 一旦代码里涉及具体的实现类, 就违反了可拔插的原则, 如果需要替换一种实现, 就需要修改代码. 为了实现在模块装配的时候不用在程序里动态指明, 这就需要一种服务发现机制",-1),h=e("p",null,"Java SPI 就是提供这样的一个机制: 为某个接口寻找服务实现的机制（这有点类似 IOC 的思想, 将装配的控制权移到了程序之外）",-1),I=e("p",null,[i("SPI 的全称是 Services Provider Interface, 翻译过来就是 "),e("strong",null,"服务提供者接口"),i(", 它所实现的是一种服务的发现机制, 可以用来启用框架扩展和替换组件")],-1),v=e("p",null,"SPI 的整体机制如下:",-1),u=e("h3",{id:"与-api-的区别",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#与-api-的区别","aria-hidden":"true"},"#"),i(" 与 API 的区别")],-1),S=e("p",null,"API: Application Programming Interface",-1),P=s('<p>从上图就看出端倪:</p><ul><li>API 概念上更接近实现方, SPI 概念上更接近调用方</li><li>API 组织上位于实现方所在的包中, SPI 组织上位于调用方所在的包中</li><li>API 实现和接口在同一个包中, API 实现在独立的包中（也可认为在提供方中）</li></ul><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h3><p>确切来说, SPI 并不是 Java 独有的, 它是一种设计思想, SPI 的本质是通过事先定义的接口来找其所有的接口实现类（服务）, 而后通过反射逐个实例化对象. 其实现原理:</p><ol><li>服务调用方定义接口, 并在主干服务中设置接入点</li><li>服务提供方实现接口, 并按照约定将实现类放在调用方可达的位置</li><li>调用方基于约定找到对应位置, 将对应接口的实现类加载到内存并连接至接入点</li><li>后续服务提供方发生变更、替换时, 只要仍然按照约定提供实现类到对应位置, 调用方无需任何更改</li></ol><p>在 JDK6 里面引进的一个新的特性 <code>ServiceLoader</code>, 从 JDK 层面实现了一种服务提供发现机制. Java 的 SPI 机制包含了两类角色, 首先是服务定义者, 涉及的概念有:</p><ul><li>Service Provider Interface(SPI): 服务提供者接口, 通常是一组接口或者抽象类, 统一定义了服务的消费形式</li><li>ServiceLoader: 服务在运行时的加载机制, 根据定义的 SPI 找到具体的实现</li></ul><p>然后是服务实现类, 涉及的概念有:</p><ul><li>Service Provider: 服务的具体实现, 是服务提供者对 SPI 的实现</li></ul><p>ServiceLoader 主要是用来装载一系列的 service provider, 而且它可以通过 service provider 的配置文件来装载指定的 service provider. 当服务的提供者提供了服务接口的一种实现之后, 我们只需要在 jar 包的 <code>META-INF/services/</code> 目录里同时创建一个以服务接口命名的文件, 该文件内容就是实现该服务接口的具体实现类. 而当外部程序装配这个模块的时候, 就能通过该 jar 包<code>META-INF/services/</code> 里的配置文件找到具体的实现类名, 并装载实例化, 完成模块的注入</p><h2 id="java-spi-的缺点" tabindex="-1"><a class="header-anchor" href="#java-spi-的缺点" aria-hidden="true">#</a> Java SPI 的缺点</h2><p>注意这里说的是 Java SPI 的缺点, SPI 是一种机制, 而 Java SPI 只是它的其中一种实现</p><ul><li>不能按需加载且获取某个实现类的方式不够灵活 <ul><li>虽然 ServiceLoader 做了延迟载入, 但是实例化的时候是通过遍历将接口的实现类得全部载入, 造成资源浪费</li><li>只支持通过 Iterator 形式迭代获取, 不能根据某个参数来获取对应的实现类</li></ul></li><li>多线程并发使用 ServiceLoader 类的实例存在安全隐患</li><li><mark>实现类不能通过有参构造器实例化</mark>（源码注释里面说明了, 因为通过反射实例化对象调用的是无参构造函数）</li></ul><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h2><ul><li>Spring 自动装配: 通过 <code>SpringFactoriesLoader.loadFactoryName()</code> 加载配置在 <code>META-INF/spring.factories</code> 中的类</li><li>JDBC 驱动加载: 基于 SPI 机制实现不同驱动的加载（JDBC 4.0 之前都是用 <code>Class.forName()</code> 的硬编码方式）</li><li>slf4j 日志门面</li></ul>',15);function _(m,f){const a=l("Mermaid");return d(),c("div",null,[n,p,h,I,v,r(a,{id:"mermaid-15",code:"eJxLy8kvT85ILCpR8AniUlAoLk1KL0osyFB4saH5+ZQVz6btBAo+m9P7tGshRORFQ6uCrq7C03WznuzsVIOIAQXsFByjIcqeLWh/2t72rG/p0/7FsUDNqXkpyOZCFYHNdYp+um7e874NzzfuNgQpdUbwjUB8FwTfGGGUo4IN0AEQc572TwTKK8TkAR0EUgl2iRMxipyJUeTCBQDj+Ia7"}),u,S,r(a,{id:"mermaid-22",code:"eJxLy8kvT85ILCpR8AniUlAoLk1KL0osyFB4saH5+ZQVz6btBAo6RT+b0/u0ayFE7EVDayxQMDUvBSSloKsLVQtk2Sk4QpU+61v6tH8xSB3cRKgE2ERHBRugvqfr5j3v2wDUlw9lPt+42xCvrBFeWWOoswC+Hl/L"}),P])}const B=o(t,[["render",_],["__file","SPI.html.vue"]]);export{B as default};
